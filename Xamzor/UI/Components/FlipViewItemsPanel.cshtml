@inherits UIElement

<div id="@Id" class="@CssClass" style="@CssStyle" ref="LayoutRoot">
    @ChildContent.SurroundWithParent(this)
</div>

@functions {

    public static readonly PropertyKey OrientationProperty = PropertyKey.Create<Orientation, FlipViewItemsPanel>(nameof(Orientation), Orientation.Horizontal);

    [Parameter]
    protected Orientation Orientation { get => Properties.Get<Orientation>(OrientationProperty); set => Properties.Set(OrientationProperty, value); }

    protected override void ComputeCss(System.Text.StringBuilder sb)
    {
        base.ComputeCss(sb);

        var isHorizontal = Orientation == Orientation.Horizontal;
        sb.Append($"overflow-{(isHorizontal ? "x" : "y")}: scroll; ");

        sb.Append($"scroll-snap-points-{(isHorizontal ? "x" : "y")}: repeat(100%); ");
        sb.Append($"-ms-scroll-snap-points-{(isHorizontal ? "x" : "y")}: snapInterval(0, 100%); ");
    }

    protected override LayoutFunc ChildLayout => Layouts.TraceSpecial(Layouts.Clip(context =>
    {
        var children = Children.OfType<UIElement>().Select(c => c.Layout).ToList();

        switch (context.Phase)
        {
            case LayoutPhase.Measure:
                foreach (var child in children)
                    child(context);

                return new Vector2(children.Count * context.Space.X, context.Space.Y);

            case LayoutPhase.Arrange:
                if (!children.Any())
                    return context.Rect;

                for (var i = 0; i < children.Count; i++)
                {
                    var childArrangeInput = context.ForArrange(
                        context.Offset + i * new Vector2(context.Space.X, 0),
                        context.Space);

                    children[i](childArrangeInput);
                }

                return new Rect(context.Offset, new Vector2(children.Count * context.Space.X, context.Space.Y));

            default:
                throw new NotImplementedException();
        }
    }));
}
