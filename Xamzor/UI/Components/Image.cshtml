@inherits UIElement

<div id="@Id" class="@CssClass" style="@LayoutCss">
    <img style="@InnerCss" src="@Source" onerror="this.style.display = 'none'" />
</div>

@functions{

        // TODO: StretchDirection is not yet supported

    public static readonly PropertyKey SourceProperty = PropertyKey.Create<string, Image>(nameof(Source));
    public static readonly PropertyKey StretchProperty = PropertyKey.Create<ImageStretch, Image>(nameof(Stretch), ImageStretch.Uniform);
    public static readonly PropertyKey StretchDirectionProperty = PropertyKey.Create<StretchDirection, Image>(nameof(StretchDirection), StretchDirection.Both);

    [Parameter] protected string Source { get => Properties.Get<string>(SourceProperty); set => Properties.Set(SourceProperty, value); }
    [Parameter] protected ImageStretch Stretch { get => Properties.Get<ImageStretch>(StretchProperty); set => Properties.Set(StretchProperty, value); }
    [Parameter] protected StretchDirection StretchDirection { get => Properties.Get<StretchDirection>(StretchDirectionProperty); set => Properties.Set(StretchDirectionProperty, value); }

    protected override void ComputeOwnLayoutCss(System.Text.StringBuilder sb)
    {
        base.ComputeOwnLayoutCss(sb);

        var size =
            Stretch == ImageStretch.Fill ? "100% 100%" :
            Stretch == ImageStretch.Uniform ? "contain" :
            Stretch == ImageStretch.UniformToFill ? "cover" :
            Stretch == ImageStretch.None ? "none" :
            throw new NotImplementedException();

        sb.Append($"background-image: url({Source}); ");
        sb.Append($"background-size: {size}; ");
        sb.Append($"background-position: {AlignmentToPosition(HorizontalAlignment)} {AlignmentToPosition(VerticalAlignment)}; ");
    }

    private string InnerCss
    {
        get
        {
            var sb = new System.Text.StringBuilder();

            if (!double.IsNaN(Width))
                sb.Append($"width: {Width}px; ");

            if (!double.IsNaN(Height))
                sb.Append($"height: {Height}px; ");

            if (MinWidth > 0)
                sb.Append($"min-width: {MinWidth}px; ");

            if (MinHeight > 0)
                sb.Append($"min-height: {MinHeight}px; ");

            if (MaxWidth != double.PositiveInfinity)
                sb.Append($"max-width: {MaxWidth}px; ");

            if (MaxHeight != double.PositiveInfinity)
                sb.Append($"max-height: {MaxHeight}px; ");

            switch (Stretch)
            {
                case ImageStretch.Fill:
                    break;

                case ImageStretch.Uniform:
                    sb.Append($"object-fit: contain; ");
                    break;

                case ImageStretch.UniformToFill:
                    sb.Append($"object-fit: cover; ");
                    break;

                case ImageStretch.None:
                    sb.Append($"object-fit: none; ");
                    break;
            }

            sb.Append($"object-position: {AlignmentToPosition(HorizontalAlignment)} {AlignmentToPosition(VerticalAlignment)}; ");


            return sb.ToString();
        }
    }

    private static string AlignmentToPosition(Alignment a) =>
        a == Alignment.Start ? "0%" :
        a == Alignment.End ? "100%" :
        a == Alignment.Center ? "50%" :
        a == Alignment.Stretch ? "50%" :
        throw new NotImplementedException();

    // TODO: 'Stretch' behavior does not match XAML 100%. If image fits into space, centering (50%) is correct.
    // If image exceeds available space, XAML aligns at start instead of center.
}